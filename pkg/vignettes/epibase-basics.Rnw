\documentclass{article}
% \VignettePackage{epibase}
% \VignetteIndexEntry{Analysis of disease outbreak data}

\usepackage{graphicx}
\usepackage[colorlinks=true,urlcolor=blue]{hyperref}
\usepackage{array}
\usepackage{color}

\usepackage[utf8]{inputenc} % for UTF-8/single quotes from sQuote()
\newcommand{\code}[1]{{{\tt #1}}}
\title{An introduction to analysing disease outbreak data using \textit{epibase} \Sexpr{packageDescription("epibase", fields = "Version")}}
\author{Thibaut Jombart, Addyour Namehere}
\date{\today}




\sloppy
\hyphenpenalty 10000


\begin{document}

\SweaveOpts{prefix.string = genomics, echo=TRUE, eval=TRUE, fig = FALSE, eps = FALSE, pdf = TRUE}



\definecolor{Soutput}{rgb}{0,0,0.56}
\definecolor{Sinput}{rgb}{0.56,0,0}
\DefineVerbatimEnvironment{Sinput}{Verbatim}
{formatcom={\color{Sinput}},fontsize=\footnotesize, baselinestretch=0.75}
\DefineVerbatimEnvironment{Soutput}{Verbatim}
{formatcom={\color{Soutput}},fontsize=\footnotesize, baselinestretch=0.75}

\color{black}

\maketitle

\begin{abstract}
  This vignette introduces the main functionalities of \textit{epibase}, a package implementing
  basic tools for the analysis of outbreak data.
  Disease outbreak data can be varied and complex, and one of the core features of \textit{epibase} lies in the formal (S4) class \texttt{obkData}, which allows for storing and handling a variety of data about individuals, samples, contact structures, or even clinical events.
  Beyond introducing this data structure, this tutorial illustrates how these objects can be handled and analyzed in R.
\end{abstract}

\newpage

\tableofcontents


\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Storing outbreak data}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this section, we first detail the structure of the core classes used for storing information in
\textit{epibase}, and then explain how to import data into the package, and how to handle data once imported.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Class definitions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Data collected during outbreaks can be hugely diverse and complex.
In \textit{epibase}, our purpose is to have a general class of objects which can store virtually any
information sampled during outbreak, without the user worrying about storage issues.
For most purposes, the core class \texttt{obkData} will be treated as a black box, with which the
user can interact using specific functions called \textit{accessors}, without having to worry about
the internal structure of the object.


% % % % % % % % % % % % % % % % %
\subsubsection{\code{obkData}: storage of outbreak data}
% % % % % % % % % % % % % % % % %
The class \texttt{ObkData} is used to store various types of information.
The definition of the class in terms of R objects can be obtained by:
<<>>=
library(epibase)
getClassDef("obkData")
@
One can also examine a structure using an empty object:
<<>>=
new("obkData")
@

Each slot of an \texttt{obkData} object is optional. By convention, empty slots are always \texttt{NULL}.
The slots respectively contain:
\begin{itemize}
\item \texttt{@individuals}: a \texttt{data.frame} storing individual data, such as age, sex,
  or onset of symptoms. If not \texttt{NULL}, this \texttt{data.frame} will have exactly one row per
  individual, with row names providing unique identifiers for individuals.
\item \texttt{@samples}: a \texttt{data.frame} storing sample data, typically swab results or
  accession numbers of DNA sequences. If not \texttt{NULL}, this \texttt{data.frame} must contain
  the three following columns: \texttt{individualID} (unique identifiers for individuals),
  \texttt{sampleID} (unique identifiers for samples), and \texttt{date} (collection dates for the samples).
\item \texttt{@clinical}: a list of \texttt{data.frame}s storing any additional clinical information;
  there is no constraint on the number of \texttt{data.frame}s stored, but each one must contain
  columns named \texttt{individualID} (unique identifiers for individuals) and \texttt{date} (date
  of observations/interventions).
  \item \texttt{@dna}: DNA sequences of one or more genes, stored as an \texttt{obkSequences}
    object. See section below for details on \texttt{obkSequences} objects.
  \item \texttt{@contacts}: dynamic contact network between the individuals, stored as an
    \texttt{obkContacts} object. See section below for details on \texttt{obkContacts} objects.
  \item \texttt{@trees}: a list of phylogenetic trees with the class \texttt{multiPhylo} (from the
    \textit{ape} package); can be used to store posterior distribution of trees from Bayesian
    software such as BEAST.
\end{itemize}

The slots of an object \texttt{foo} can be accessed using \texttt{foo@[name-of-the-slot]}.
Let us use a toy dataset created taken from the \texttt{obkData} documentation; for now, we
overlook the data creation process, and just focus on the content of the object \texttt{x}:
<<echo=FALSE>>=
ind <- data.frame("individualID"=c("toto","John Doe", "titi"), age=c(20,18,67), sex=c("m","m","?"))
samp <- data.frame(individualID=c('toto','toto','titi'), sampleID=c(1,3,2),
                   date=c("2001-02-13","2001-03-01","2001-05-25"), swab=c("+","-","+"),
                   sequenceID=c("No304","No306","No305"))
data(woodmouse)
dat.dna <- as.list(woodmouse)
x <- new("obkData", individuals=ind, samples=samp, dna=dat.dna)
@
<<>>=
class(x)
slotNames(x)
x
@

\noindent \texttt{x} is an \texttt{obkData} object containing information on individuals (three
people, with unique identifier for each row), samples (the same sample could be appearing multiple
times), and some DNA sequences.
Note the presence of the mandatory columns in \texttt{@samples}: \texttt{individualID},
\texttt{sampleID}, and \texttt{date}.
As DNA sequences are also present, \texttt{@samples} also contains a column \texttt{sequenceID} with
unique sequence identifier, matching labels used in \texttt{@dna}.
As no locus information is provided in \texttt{@samples}, it is assumed that all sequences are of
the same gene.
Otherwise, there should be a column \texttt{locus} in \texttt{@samples} containing this information.
Accessing a given slot is as easy as:
<<>>=
x@individuals
x@samples
@




% % % % % % % % % % % % % % % % %
\subsubsection{\texttt{obkSequences}: storage of DNA sequences for different genes}
% % % % % % % % % % % % % % % % %

Pathogen sequence data can typically be obtained for a range of different genes, making the handling of such information not entirely trivial.
The class \texttt{obkSequences} stores such information.
It consists in a list of matrices of aligned DNA sequences (in rows), stored using \textit{ape}'s class
\texttt{DNAbin} for efficiency, with each item of the list corresponding to a gene.
If provided, gene names are the names of the list.
The row names for each matrix contain unique identifiers for the sequences, typically accession numbers.
Matching of samples and sequences in made in the \texttt{obkData} objects through the field
\texttt{sequenceID} in the \texttt{@sample} slot.
When several loci have been sequenced, the locus information must also be provided for each
accession number using a column \texttt{locus} in the \texttt{@sample} slot.

Again, let us look at a toy example without paying attention to how data are created:
<<echo=FALSE>>=
x <- new("obkSequences", dna=woodmouse, locus=rep(c("gene1", "HighGene", "Phage foobar"), c(10,1,4)))
@
<<>>=
class(x)
slotNames(x)
x
class(x@dna$"gene1")
@

\noindent \texttt{x} is an \texttt{obkSequences} object containing three genes.
Data are stored in the unique slot \texttt{@dna}, which is a list of \texttt{DNAbin} matrices.




% % % % % % % % % % % % % % % % %
\subsubsection{\code{obkContacts}: storage of dynamics contact networks}
% % % % % % % % % % % % % % % % %








%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Getting data into \textit{epibase}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Storing data in \textit{epibase} requires the following, fairly simple steps:
\begin{enumerate}
\item read data into R
  \begin{enumerate}
  \item read \texttt{data.frame}s storing individuals, samples, and clinical information in R from a
    text file, typically using \texttt{read.table} or \texttt{read.csv} for comma-separated
    files. Every standard spreadsheet software can export data to these formats.
  \item read DNA sequences from a single file, typically using \texttt{read.dna} from the ape
    package; this ``master'' file must contain all DNA sequences of all genes, with unique
    identifiers for the sequences as labels
  \end{enumerate}
\item use this information as input to the \texttt{obkData} constructor (\texttt{new("obkData",\ldots)}) to create an
  \texttt{obkData} object.
\end{enumerate}

In the following, we assume that step 1 is sorted and focus on step 2: using the constructor.



% % % % % % % % % % % % % % % % %
\subsubsection{The \code{obkData} constructor}
% % % % % % % % % % % % % % % % %

New objects are created using \texttt{new}, with these slots as arguments.
If no argument is provided, an empty object is created, as seen before:
<<>>=
new("obkData")
@

\noindent This function accepts the following arguments, which mirror to some extent the structure
of the object (see \texttt{?obkData} for more information):
\begin{itemize}
  \item \texttt{individuals}: a \texttt{data.frame} with a mandatory column named 'individualID', providing unique identifiers for the individuals.
    \item \texttt{samples}: a \texttt{data.frame} with 3 mandatory columns named 'individualID', 'sampleID', and 'date', providing identifiers for
      the individuals, for the samples, and dates. Dates must be provided in a way convertible to
      \texttt{Date} (see \texttt{?as.Date}). Default format for dates provided as characters  is
      "\%Y-\%m-\%d" (e.g. 1984-09-23). Alternative format can be specified via the argument \texttt{date.format}.
    \item \texttt{clinical}: a list of \texttt{data.frame}s, each of which has 2 mandatory fields,
      individualID' and 'date' (specified as before).
    \item \texttt{dna}: a list of DNA sequences in \texttt{DNAbin} or \texttt{character} format, as
      read by \texttt{read.dna}.
    \item \texttt{contacts}: to be filled.
    \item \texttt{trees}: a list of phylogenetic trees in the class \texttt{multiPhylo} (from the
      ape package); this is basically a list of \texttt{phylo} objects, with the class ``\texttt{multiPhylo}''.
\end{itemize}

\noindent We can now show how the toy example previously used was created.
Arguments \texttt{ind} and \texttt{samp} are \texttt{data.frame}s with some of the required fields:
<<>>=
ind
samp
samp$date
@
Note that dates are in the right format, but are actually mis-specified as they are stored as a
\texttt{factor}. As this is frequent (characters are stored as factors in \texttt{data.frame}s
unless \texttt{options("stringsAsFactors")} is set to \texttt{FALSE}), the constructor is designed
to accommodate this issue.

DNA sequences have been taken from \texttt{data(woodmouse)} for the sake of merely have sequences to
play with:
<<>>=
data(woodmouse)
dat.dna <- as.list(woodmouse)
dat.dna
@

\noindent And then \texttt{obkData} object was simply created using:
<<>>=
x <- new("obkData", individuals=ind, samples=samp, dna=dat.dna)
@
Note some slight differences from the inputs.
Individuals labels are now used to name the rows of \texttt{@individuals}:
<<>>=
x@individuals
@
And dates are stored as proper dates, supporting basic mathematical operations:
<<>>=
class(x@samples$date)
x@samples$date
x@samples$date + 1
x@samples$date + 365
@
Some other, invisible checks have also been made when creating the object.
For instance, it has been checked that every sampled individual is documented in
\texttt{@individuals} (otherwise, a warning would have been issued), and that every sequence
referred in \texttt{x@samples\$sequenceID} was indeed in the list of DNA sequences in \texttt{@dna}
(an error would have been issued otherwise, along with a list of faulty accession numbers).


% % % % % % % % % % % % % % % % %
\subsubsection{The \code{obkSequences} constructor}
% % % % % % % % % % % % % % % % %


% % % % % % % % % % % % % % % % %
\subsubsection{The \code{obkContacts} constructor}
% % % % % % % % % % % % % % % % %








%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Data handling using \texttt{obkData} objects}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Accessors}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



The phylosophy underlying formal (S4) classes is that the internal representation of the data can be
complex as long as accessing this information is simple.
This is made possible by decoupling storage and accession: the user is not meant to access the
content of the object directly, but has to use \texttt{accessors} to retrieve or modify the information.
\\


% % % % % % % % % % % % % % % % %
\subsubsection{Accessors for \code{obkData} objects}
% % % % % % % % % % % % % % % % %

Available accessors are documented in \code{?obkData}.
\begin{itemize}
  \item \texttt{}: returns ...
  \item \texttt{}: returns ...
\end{itemize}




% % % % % % % % % % % % % % % % %
\subsubsection{Accessors for \code{obkSequences} objects}
% % % % % % % % % % % % % % % % %



% % % % % % % % % % % % % % % % %
\subsubsection{Accessors for \code{obkContacts} objects}
% % % % % % % % % % % % % % % % %






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Subsetting the data}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Graphics for \texttt{obkData} objects}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\end{document}
